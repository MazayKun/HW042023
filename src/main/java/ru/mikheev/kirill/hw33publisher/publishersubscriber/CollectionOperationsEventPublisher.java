package ru.mikheev.kirill.hw33publisher.publishersubscriber;

import ru.mikheev.kirill.hw33publisher.collection.EventPublishingSupportedCollection;
import ru.mikheev.kirill.hw33publisher.publishersubscriber.events.AddEvent;
import ru.mikheev.kirill.hw33publisher.publishersubscriber.events.RemoveEvent;

import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Предназначен для публикации событий об операциях, проводимых над коллекциями
 */
public class CollectionOperationsEventPublisher {

    private final List<EventListener<RemoveEvent>> removeEventListeners = new CopyOnWriteArrayList<>();
    private final List<EventListener<AddEvent>> addEventListeners = new CopyOnWriteArrayList<>();

    private final BlockingQueue<CollectionEvent> eventsQueue = new LinkedBlockingDeque<>();

    private final Lock workerLock = new ReentrantLock();
    private final Condition newEventAvailableCondition = workerLock.newCondition();
    private Thread workerThread;

    public CollectionOperationsEventPublisher() {
        startPublisher();
    }

    /**
     * Публикация события о том, что элемент был удален из коллекции
     *
     * @param collection - коллекция, над которой проводилась операция
     * @param removedObject - удаленный эелмент
     */
    public void publishRemove(EventPublishingSupportedCollection collection, Object removedObject) {
        eventsQueue.add(new RemoveEvent(collection, removedObject));
        newEventSignal();
    }

    /**
     * Публикация события о том, что элемент был добавлен в коллекцию
     *
     * @param collection - коллекция, над которой проводилась операция
     * @param addedObject - добавленный элемент
     */
    public void publishAdd(EventPublishingSupportedCollection collection, Object addedObject) {
        eventsQueue.add(new AddEvent(collection, addedObject));
        newEventSignal();
    }

    /**
     * Запустить новый поток обработки событий
     * @throws RuntimeException если уже имеется поток обработки событий
     */
    public void startPublisher() {
        if(workerThread != null) throw new RuntimeException("Worker thread already exists");
        this.workerThread = new Thread(() -> {
            try {
                while (Thread.currentThread() == workerThread) {
                    if(!eventsQueue.isEmpty()) processAllAvailableEvents();
                    workerLock.lock();
                    newEventAvailableCondition.await(500L, TimeUnit.MILLISECONDS);
                    workerLock.unlock();
                }

            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        this.workerThread.setDaemon(true);
        this.workerThread.start();
    }

    /**
     * Останавливает поток обработки событий
     */
    public void stopPublisher() {
        workerThread = null;
    }

    /**
     * Подписывает новый обработчик событий об удалении элемента из коллекции
     * @param newListener - обработчик, который нужно подписать
     */
    public void subscribeRemoveEventListener(EventListener<RemoveEvent> newListener) {
        removeEventListeners.add(newListener);
    }

    /**
     * Подписывает новый обработчик событий о добавлении нового элемента в коллекции
     * @param newListener - обработчик, который нужно подписать
     */
    public void subscribeAddEventListener(EventListener<AddEvent> newListener) {
        addEventListeners.add(newListener);
    }

    /**
     * Сигнализирует потоку обработки событий о том, что появилось новое событие
     */
    private void newEventSignal() {
        workerLock.lock();
        newEventAvailableCondition.signalAll();
        workerLock.unlock();
    }

    /**
     * Обрабатывает все доступные на данный момент события
     */
    private void processAllAvailableEvents() {
        CollectionEvent event;
        while((event = eventsQueue.poll()) != null) {
            if(event instanceof AddEvent addEvent) {
                for(var listener : addEventListeners) {
                    listener.notify(addEvent);
                }
            }

            if(event instanceof RemoveEvent removeEvent) {
                for(var listener : removeEventListeners) {
                    listener.notify(removeEvent);
                }
            }
        }
    }
}
